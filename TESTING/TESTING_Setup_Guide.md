# ExpL Compiler Testing - Directory Structure & Setup Guide

## 1. DIRECTORY STRUCTURE

```
root-dir/
├── xsm                                    # XSM simulator (executable)
├── library.lib                            # Required library for XSM
│
├── stage-1/
│   ├── Makefile                          # For compiling stage-1 compiler
│   ├── task1.l                           # Lexer
│   ├── task1.y                           # Parser
│   ├── tree.h / tree.c                   # AST implementation
│   ├── codegeneration.c                  # Code generation
│   ├── register.c / labels.c             # Helper modules
│   ├── y.tab.c / y.tab.h                 # Generated by yacc
│   ├── lex.yy.c                          # Generated by lex
│   └── stage-final                       # Final executable
│
├── stage-2/                              # (Similar structure to stage-1)
│   ├── Makefile
│   ├── task2.l / task2.y
│   ├── (other .c/.h files)
│   └── stage-final
│
├── stage-3/                              # (Similar structure)
│   ├── Makefile
│   ├── task3.l / task3.y
│   └── stage-final
│
├── stage-4/                              # (Similar structure)
│   ├── Makefile
│   ├── task4.l / task4.y
│   ├── symboltable.h / symboltable.c
│   └── stage-final
│
└── TESTING/
    ├── Makefile                          # Testing Makefile (provided above)
    ├── input/                            # Test input files
    │   ├── stage-1-case-1-compilation.txt
    │   ├── stage-1-case-2-compilation.txt
    │   ├── stage-1-case-2-input.txt      # (if needed)
    │   ├── stage-2-case-1-compilation.txt
    │   ├── stage-2-case-1-input.txt
    │   ├── stage-3-case-1-compilation.txt
    │   ├── stage-3-case-1-input.txt
    │   ├── stage-4-case-1-compilation.txt
    │   └── ...
    │
    ├── expected_output/                  # Expected outputs
    │   ├── stage-1-case-1-xsm.txt
    │   ├── stage-1-case-2-xsm.txt
    │   ├── stage-2-case-1-xsm.txt
    │   ├── stage-2-case-1-runtime.txt
    │   ├── stage-3-case-1-runtime.txt
    │   ├── stage-4-case-1.err            # (Error test)
    │   └── ...
    │
    └── output/                           # Actual outputs (generated during testing)
        ├── stage-1-case-1-xsm.txt
        ├── stage-1-case-1-runtime.txt
        ├── stage-2-case-1-xsm.txt
        ├── stage-2-case-1-runtime.txt
        └── ... (populated by make test)
```

---

## 2. NAMING CONVENTIONS

### Test Input Files
- **Compilation-only tests** (no runtime):
  ```
  input/stage-X-case-N-compilation.txt
  ```
  
- **With runtime input**:
  ```
  input/stage-X-case-N-compilation.txt   (source code)
  input/stage-X-case-N-input.txt         (stdin for XSM)
  ```

### Expected Output Files
- **Compilation output** (for Stages 1, with AST):
  ```
  expected_output/stage-1-case-N-xsm.txt
  ```
  
- **Runtime output**:
  ```
  expected_output/stage-X-case-N-runtime.txt  (stdout from XSM)
  expected_output/stage-X-case-N-input.txt    (stdin for XSM)
  ```

- **Error tests**:
  ```
  expected_output/stage-X-case-N.err
  ```
  Contains expected error message (e.g., `[ERROR] Undeclared variable 'x'`)

### Actual Output Files (Generated)
```
output/stage-X-case-N-xsm.txt           # Compiler output (AST/code)
output/stage-X-case-N-runtime.txt       # XSM execution output
```

---

## 3. SAMPLE TEST CASE FILES

### STAGE 1: Test Case 1 (Single Number)

**File: input/stage-1-case-1-compilation.txt**
```
3
```

**File: expected_output/stage-1-case-1-xsm.txt**
```
MOV R0, 3
MOV [4096], R0
INT 10
INT 5
INT 2
```
(Output format depends on your code generation)

---

### STAGE 2: Test Case 1 (Simple Read/Write)

**File: input/stage-2-case-1-compilation.txt**
```
begin
  read(a);
  write(a);
end
```

**File: input/stage-2-case-1-input.txt**
```
42
```

**File: expected_output/stage-2-case-1-runtime.txt**
```
42
```

---

### STAGE 2: Test Case 2 (Assignment & Operations)

**File: input/stage-2-case-2-compilation.txt**
```
begin
  a = 5;
  b = 10;
  c = a + b;
  write(c);
end
```

**File: input/stage-2-case-2-input.txt**
(empty - no read statements)

**File: expected_output/stage-2-case-2-runtime.txt**
```
15
```

---

### STAGE 3: Test Case 1 (IF-THEN)

**File: input/stage-3-case-1-compilation.txt**
```
begin
  a = 5;
  if (a > 3) then
    write(1);
  endif
end
```

**File: input/stage-3-case-1-input.txt**
(empty)

**File: expected_output/stage-3-case-1-runtime.txt**
```
1
```

---

### STAGE 3: Test Case 2 (IF-THEN-ELSE)

**File: input/stage-3-case-2-compilation.txt**
```
begin
  x = 2;
  if (x > 5) then
    write(100);
  else
    write(200);
  endif
end
```

**File: expected_output/stage-3-case-2-runtime.txt**
```
200
```

---

### STAGE 3: Test Case 3 (WHILE Loop)

**File: input/stage-3-case-3-compilation.txt**
```
begin
  i = 0;
  while (i < 3) do
    write(i);
    i = i + 1;
  endwhile
end
```

**File: expected_output/stage-3-case-3-runtime.txt**
```
0
1
2
```

---

### STAGE 4: Test Case 1 (Type Checking - Success)

**File: input/stage-4-case-1-compilation.txt**
```
decl
  int a, b;
  str msg;
enddecl

begin
  a = 10;
  b = 20;
  msg = "hello";
  write(a);
  write(msg);
end
```

**File: expected_output/stage-4-case-1-runtime.txt**
```
10
hello
```

---

### STAGE 4: Test Case 2 (Type Error - Undeclared Variable)

**File: input/stage-4-case-2-compilation.txt**
```
decl
  int x;
enddecl

begin
  y = 5;
  write(y);
end
```

**File: expected_output/stage-4-case-2.err**
```
[ERROR] Undeclared variable 'y' at line 5
```

---

### STAGE 4: Test Case 3 (Type Mismatch in Assignment)

**File: input/stage-4-case-3-compilation.txt**
```
decl
  int num;
  str text;
enddecl

begin
  num = "wrong type";
end
```

**File: expected_output/stage-4-case-3.err**
```
[ERROR] Type mismatch in assignment: expected int, got str
```

---

### STAGE 4: Test Case 4 (Type Mismatch in Arithmetic)

**File: input/stage-4-case-4-compilation.txt**
```
decl
  int x;
  str s;
enddecl

begin
  s = "test";
  x = s + 5;
end
```

**File: expected_output/stage-4-case-4.err**
```
[ERROR] Type mismatch in operation: cannot add str and int
```

---

### STAGE 4: Test Case 5 (Redeclaration Error)

**File: input/stage-4-case-5-compilation.txt**
```
decl
  int a;
  int a;
enddecl

begin
end
```

**File: expected_output/stage-4-case-5.err**
```
[ERROR] Variable 'a' already declared
```

---

## 4. HOW TO RUN TESTS

### Run All Tests
```bash
cd root-dir/TESTING
make test
```

### Run Only Stage 1 Tests
```bash
cd root-dir/TESTING
make test-stage-1
```

### Run Only Stage 4 Tests
```bash
cd root-dir/TESTING
make test-stage-4
```

### Clean Output Files
```bash
cd root-dir/TESTING
make clean
```

### View Help
```bash
cd root-dir/TESTING
make help
```

---

## 5. TEST EXECUTION FLOW

The Makefile follows this logic for each test:

### For Stages 1-3 (Compilation + Execution):
```
1. Read test input file (compilation.txt)
2. Run compiler: stage-final < input > output/stage-X-case-N-xsm.txt
3. Check for expected errors (if .err file exists)
   - If expected error: Compare error output
   - If success expected: Run XSM simulator
4. Run XSM simulator with input data (if input.txt exists)
5. Compare runtime output with expected_output/*.txt
6. Report PASS/FAIL with color codes
```

### For Stage 4 (With Type Checking):
```
1-6. Same as stages 1-3
7. Additional: Can validate symbol table output if needed
```

---

## 6. EXPECTED OUTPUT FILE FORMATS

### For successful compilation tests (stage-1):
Output shows AST representation or generated code:
```
+
├── 3
└── 2

Prefix: + 3 2
Postfix: 3 2 +
```

### For runtime output tests (stages 2-4):
Simple stdout output from XSM execution:
```
42
15
0
1
2
```

### For error tests:
Error message matching the pattern:
```
[ERROR] Undeclared variable 'x'
[ERROR] Type mismatch in assignment
[ERROR] Variable 'a' already declared
```

---

## 7. ADDING NEW TESTS

To add a new test case `stage-2-case-10`:

1. Create input file:
   ```bash
   cat > input/stage-2-case-10-compilation.txt << 'EOF'
   begin
     a = 100;
     write(a);
   end
   EOF
   ```

2. Create expected output:
   ```bash
   echo "100" > expected_output/stage-2-case-10-runtime.txt
   ```

3. Run test:
   ```bash
   cd TESTING && make test-stage-2
   ```

---

## 8. TEST NAMING QUICK REFERENCE

| Test Type | Input File | Output File(s) | Notes |
|-----------|-----------|----------------|-------|
| Compilation-only | stage-X-case-N-compilation.txt | stage-X-case-N-xsm.txt | Verify AST/code generation |
| With input | stage-X-case-N-compilation.txt + stage-X-case-N-input.txt | stage-X-case-N-runtime.txt | Verify execution results |
| Error expected | stage-X-case-N-compilation.txt | stage-X-case-N.err | Verify error messages |
| No input | stage-X-case-N-compilation.txt | stage-X-case-N-runtime.txt | Execution without stdin |

---

## 9. TROUBLESHOOTING

### Test fails with "COMPILER ERROR"
- Check if `stage-X/stage-final` exists and is executable
- Check `$(STAGE_X_COMPILER)` path in Makefile

### Test fails with "NO EXPECTED OUTPUT"
- Create the expected output file in `expected_output/`

### Output mismatch but looks similar
- Makefile uses `diff -w -B` (ignore whitespace)
- If still failing, check for trailing spaces, newlines, tabs
- Use `hexdump -C` to debug

### "SKIP - NO EXPECTED OUTPUT"
- This is normal if you haven't created expected output yet
- Create the `.txt` file in `expected_output/`

### XSM simulator not found
- Ensure `$(ROOT_DIR)/xsm` exists and is executable
- Update `XSM_SIMULATOR` path in Makefile if needed

---

## 10. COMPLETE SETUP CHECKLIST

- [ ] Create `TESTING/` directory
- [ ] Copy `Makefile` to `TESTING/`
- [ ] Create `TESTING/input/` directory
- [ ] Create `TESTING/expected_output/` directory
- [ ] Create `TESTING/output/` directory (will be created by Makefile)
- [ ] Add test input files (stage-X-case-N-compilation.txt)
- [ ] Add expected output files (stage-X-case-N-runtime.txt or .err)
- [ ] Ensure all stage compilers are built (`stage-final` executables)
- [ ] Run `make help` to verify Makefile works
- [ ] Run `make test-stage-1` to test first stage
- [ ] Iterate and add more tests

This setup provides:
✓ Automated testing for all 4 stages
✓ Error detection and reporting
✓ Color-coded pass/fail output
✓ Parallel test execution
✓ Modular stage-wise testing
✓ Easy test case addition
